package game.level.random;

import game.level.Level;

import java.awt.Color;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Random;

@SuppressWarnings("unused")
public class RandomLevel extends Level {

	private final Random random = new Random();
	private ArrayList<Room> rooms = new ArrayList<Room>();
	private ArrayList<Room> bigRooms = new ArrayList<Room>();
	private ArrayList<Room> smallRooms = new ArrayList<Room>();
	private ArrayList<Room> tempRooms = new ArrayList<Room>();

	/**
	 * 1 : sizes of the bounds 2 : sizes of the big rooms 3 : sizes of the small
	 * rooms (big rooms / 2)
	 **/
	private int w1, w2, w3, h1, h2, h3;
	private int bigRoomSize, smallRoomSize;

	private Room[] bounds = new Room[2];

	public RandomLevel(int difficulty) {
		super(difficulty);

		width = 100;
		height = width * 10 / 16;

		w1 = (int) (width / 2.5);
		h1 = w1 / 2;
		w2 = 20 * width / 100;
		h2 = (int) (w2 / 1.618);
		w3 = w2 / 2;
		h3 = h2 / 2;
		
		bigRoomSize = 10;
		smallRoomSize = 25;

		generateLevel();
		removeRooms();
	}

	protected void generateLevel() {
		generateBounds();
		generateRooms();
	}

	private void generateBounds() {
		while (true) {
			bounds[0] = new Bound(w1, h1, this);
			break;
		}

		while (true) {
			// Swaps the places of w1 and h1 so that one bound will "stand" and
			// the other "lie"
			bounds[1] = new Bound(h1, w1, this);

			if (bounds[1].getRectangle().intersects(bounds[0].getRectangle())) {
				int[] sort = new int[4];
				int x0, x1, y0, y1;

				// This could be done in a for lopp but takes longer code and
				// gets less readable
				sort[0] = bounds[0].getX();
				sort[1] = bounds[0].getX() + bounds[0].getWidth();
				sort[2] = bounds[1].getX();
				sort[3] = bounds[1].getX() + bounds[1].getWidth();

				sort = sort(sort);

				x0 = sort[1];
				x1 = sort[2];

				sort[0] = bounds[0].getY();
				sort[1] = bounds[0].getY() + bounds[0].getHeight();
				sort[2] = bounds[1].getY();
				sort[3] = bounds[1].getY() + bounds[1].getHeight();

				sort = sort(sort);

				y0 = sort[1];
				y1 = sort[2];

				// This gets the area of the bounds rects and subtracts the area
				// of the intersection
				int boundsArea = (bounds[0].getWidth() * bounds[0].getHeight()) + (bounds[1].getWidth() * bounds[1].getHeight()) - (x1 - x0) * (y1 - y0);

				// If the bounds cover 30 % - 40 % of the screen, it should
				// break
				if (width * height * 0.3 < boundsArea && boundsArea < width * height * 0.4) {
					break;
				}
			}
		}

	}

	private void generateRooms() {
		bigRooms = addRooms(bigRoomSize, w2, h2, bigRooms);
		smallRooms = addRooms(smallRoomSize, w3, h3, smallRooms);

		// Adds the different rooms to a new array
		rooms.addAll(bigRooms);
		rooms.addAll(smallRooms);
	}

	private ArrayList<Room> addRooms(int size, int width, int height, ArrayList<Room> rooms) {
		for (int i = 0; i < size; i++) {
			intersectionDetection: while (true) {
				int w = random.nextBoolean() ? width : height;
				int h = (w == width) ? height : width;
				Room r = new Room(w, h, this);

				boolean intersects = false;

				for (Room room : rooms) {
					if (r.getRectangle().intersects(room.getRectangle())) intersects = true;
				}

				if (!intersects) {
					rooms.add(r);
					break intersectionDetection;
				}
			}
		}
		return rooms;
	}

	private void removeRooms() {
		tempRooms = rooms;
		
		for (Room r : tempRooms) {
			boolean intersects = false;
			for (Room b : bounds) {
				if (r.getRectangle().intersects(b.getRectangle())) {
					intersects = true;
				}
			}
			if(!intersects) r.remove();
		}
		
		for(int i = 0; i <tempRooms.size(); i++) {
			if(!tempRooms.get(i).isRemoved()) rooms.add(tempRooms.get(i));
		}
	}

	protected int[] sort(int[] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < i; j++) {
				if (array[i] < array[j]) {
					int temp = array[i];
					array[i] = array[j];
					array[j] = temp;
				}
			}
		}

		return array;
	}

	public int getWidth() {
		return width;
	}

	public int getHeight() {
		return height;
	}

	public void draw(Graphics g, double scale) {
		if (rooms.size() != 0) {

			g.setColor(Color.magenta);
			g.fillRect((int) (1 * scale), (int) (1 * scale), (int) (width * scale), (int) (height * scale));
			g.setColor(Color.green);

			for (int i = 0; i < rooms.size(); i++) {
				Room r = rooms.get(i);
				if(!r.isRemoved())
				g.fillRect((int) (r.getX() * scale), (int) (r.getY() * scale), (int) (r.getWidth() * scale), (int) (r.getHeight() * scale));
			}

			for (int i = 0; i < bounds.length; i++) {
				g.setColor(Color.yellow);

				Room b = bounds[i];

				g.drawRect((int) (b.getX() * scale), (int) (b.getY() * scale), (int) (b.getWidth() * scale), (int) (b.getHeight() * scale));
			}

			g.setColor(Color.blue);
			g.fillRect((int)(10 * scale), (int)(10 * scale), (int)scale, (int)scale);
		}
	}

}
