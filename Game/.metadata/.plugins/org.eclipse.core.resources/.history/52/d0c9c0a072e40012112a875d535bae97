package game.level.random;

import game.level.Level;

import java.awt.Color;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Random;

@SuppressWarnings("unused")
public class RandomLevel extends Level {

	private final Random random = new Random();
	private ArrayList<Room> rooms = new ArrayList<Room>();
	private ArrayList<Room> bigRooms = new ArrayList<Room>();
	private ArrayList<Room> smallRooms = new ArrayList<Room>();
	private ArrayList<Room> newRooms = new ArrayList<Room>();

	/**
	 * 1 : sizes of the bounds 2 : sizes of the big rooms 3 : sizes of the small
	 * rooms (big rooms / 2)
	 **/
	private int w1, w2, w3, h1, h2, h3;
	private int bigRoomSize = 5, smallRoomSize = 15;

	private Room[] bounds = new Room[2];

	public RandomLevel(int difficulty) {
		super(difficulty);

		width = 200;
		height = width * 10 / 16;

		w1 = (int) (width / 2.5);
		h1 = w1 / 2;
		w2 = 16;
		h2 = (int) (w2 / 1.618);
		w3 = w2 / 2;
		h3 = h2 / 2;

		generateLevel();
	}

	protected void generateLevel() {
		rooms.add(new Room(w2, h2, this));
		generateBounds();
		generateRooms();
	}

	private void generateBounds() {
		while (true) {
			bounds[0] = new Bound(w1, h1, this);
			break;
		}

		while (true) {
			// Swaps the places of w1 and h1 so that one bound will "stand" and
			// the other "lie"
			bounds[1] = new Bound(h1, w1, this);

			if (bounds[1].getRectangle().intersects(bounds[0].getRectangle())) {
				int[] sort = new int[4];
				int x0, x1, y0, y1;

				// This could be done in a for lopp but takes longer code and
				// gets less readable
				sort[0] = bounds[0].getX();
				sort[1] = bounds[0].getX() + bounds[0].getWidth();
				sort[2] = bounds[1].getX();
				sort[3] = bounds[1].getX() + bounds[1].getWidth();

				sort = sort(sort);

				x0 = sort[1];
				x1 = sort[2];

				sort[0] = bounds[0].getY();
				sort[1] = bounds[0].getY() + bounds[0].getHeight();
				sort[2] = bounds[1].getY();
				sort[3] = bounds[1].getY() + bounds[1].getHeight();

				sort = sort(sort);

				y0 = sort[1];
				y1 = sort[2];

				// This gets the area of the bounds rects and subtracts the area
				// of the intersection
				int boundsArea = (bounds[0].getWidth() * bounds[0].getHeight()) + (bounds[1].getWidth() * bounds[1].getHeight()) - (x1 - x0) * (y1 - y0);

				// If the bounds cover 30 % - 40 % of the screen, it should
				// break
				if (width * height * 0.3 < boundsArea && boundsArea < width * height * 0.4) {
					break;
				}
			}
		}

	}

	private void generateRooms() {
		for(int i = 0; i < bigRoomSize; i++) {
			intersectionDetection: while(true) {
				int w = random.nextBoolean() ? w2 : h2;
				int h = (w == w2) ? h2 : w2;
				Room r = new Room(w, h, this);
				
				boolean intersects = false;
				
				for(Room room : bigRooms) {
					if(r.getRectangle().intersects(room.getRectangle()))
						intersects = true;
				}
				
				if(!intersects) {
					bigRooms.add(r);
					rooms.add(r);
					System.out.println("added a new room");
					break intersectionDetection;
				}
			}
		}
	}

	protected int[] sort(int[] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < i; j++) {
				if (array[i] < array[j]) {
					int temp = array[i];
					array[i] = array[j];
					array[j] = temp;
				}
			}
		}

		return array;
	}

	public int getWidth() {
		return width;
	}

	public int getHeight() {
		return height;
	}

	public void draw(Graphics g, double scale) {
		if (rooms.size() != 0) {
			Room r = rooms.get(0);

			g.setColor(Color.magenta);
			g.fillRect((int) (1 * scale), (int) (1 * scale), (int) (width * scale), (int) (height * scale));
			g.setColor(Color.green);
			g.fillRect((int) (r.getX() * scale), (int) (r.getY() * scale), (int) (r.getWidth() * scale), (int) (r.getHeight() * scale));

			for (int i = 0; i < bounds.length; i++) {
				g.setColor(Color.yellow);

				Room b = bounds[i];

				g.drawRect((int) (b.getX() * scale), (int) (b.getY() * scale), (int) (b.getWidth() * scale), (int) (b.getHeight() * scale));
			}
		}
	}

}
