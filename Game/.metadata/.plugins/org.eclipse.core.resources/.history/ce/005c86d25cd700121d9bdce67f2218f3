package game.entity.mob.AI;

import game.entity.mob.Mob;
import game.entity.mob.Player;

public class Stalker extends AI {

	public Stalker() {
		sprite = sprite.shot;
		speed = 0.5;
		range = 200;
		randomTick = randomTick();
	}

	int i = 0;

	public void tick(Mob player) {
		super.tick();

		tickCount++;

		if (seesPlayer(player)) {
			seenPlayer = true;
			//System.out.println("I can see you!");
		}

		if (tickCount > randomTick || collided) {
			tickCount = 0;
			randomTick = randomTick();

			double dx = player.getX() - x;
			double dy = player.getY() - y;

			if (collided) {
				angle = Math.toRadians(random.nextInt(360));

				seenPlayer = false;
				collided = false;
			} else {
				if (seenPlayer) {
					angle = Math.atan2(dy, dx);
				} else {
					angle = Math.toRadians(random.nextInt(360));
				}
			}

			xDir = Math.cos(angle) * speed;
			yDir = Math.sin(angle) * speed;

		}

		// move(xDir, yDir);

		if (seesPlayer(player)) {
			i++;
			System.out.println(i);
		}
	}

	private void getLineEquation(double x0, double x1, double y0, double y1) {
		k = (y0 - y1) / (x0 - x1);
		m = (y0 - x0 * k) / 16;
	}

	protected boolean seesPlayer(Mob player) {
		int tileSize = game.getTileSize();

		if (x != player.getX()) getLineEquation(x + sprite.getSize() / 2, player.getX() + player.getSprite().getSize() / 2, y + sprite.getSize() / 2, player.getY() + player.getSprite().getSize() / 2);

		// System.out.println("y = " + k + "x + " + m);

//		int x0 = (int) ((x < player.getX()) ? x : player.getX()) >> 4;
//		int x1 = ((int) ((x + sprite.getSize()> player.getX() + player.getSprite().getSize()) ? x + sprite.getSize() : player.getX()) + player.getSprite().getSize() - 1) >> 4;
//		int y0 = (int) ((y< player.getY()) ? y + sprite.getSize() / 2 : player.getY())>> 4;
//		int y1 = ((int) ((y + sprite.getSize() > player.getY() + player.getSprite().getSize()) ? y + sprite.getSize() : player.getY())+ player.getSprite().getSize() -1)>> 4;
		
		double x0 = (x < player.getX()) ? x : player.getX();
		double x1 = (x + sprite.getSize()> player.getX() + player.getSprite().getSize()) ? x + sprite.getSize() : player.getX() + player.getSprite().getSize() - 1;
		double y0 = (y < player.getY()) ? y : player.getY();
		double y1 = (y + sprite.getSize() > player.getY() + player.getSprite().getSize()) ? y + sprite.getSize() : player.getY() + player.getSprite().getSize() -1;
		
//		System.out.println("x0: " + x0);
//		System.out.println("x1: " + x1);
//		System.out.println("y0: " + y0);
//		System.out.println("y1: " + y1);

		for (double yy = y0; yy < y1; yy += tileSize) {
			if (!(x0 <= x1 && x1 < x0 + tileSize)) {
				for (double xx = x0; xx <= x1; xx += tileSize) {
					
					//System.out.println((int)(xx/16) + ", " + (int)(yy/16));
					
					if (level.getTile((int)xx / 16, (int)yy / 16).isSolid()) {
						if (yy <= xx * k + m && xx * k + m < yy + tileSize) return false;
						if (xx <= (yy - m) / k && (yy - m) / k < xx + tileSize) return false;
					}

				}
			} else if (level.getTile((int)x1 / 16, (int)yy / 16).isSolid()) return false;

		}

		// The value of the first parameter is changed (+1). By doing this, it
		// prevents the AI to spot the player when the situation is like this:
		// P = player
		// M = AI
		// X = wall
		// PX
		// XM
		// If this would not be done, the AI would be able to look through the
		// walls
		
		return true;
	}
}
